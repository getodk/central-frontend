<!--
Copyright 2017 ODK Central Developers
See the NOTICE file at the top-level directory of this distribution and at
https://github.com/getodk/central-frontend/blob/master/NOTICE.

This file is part of ODK Central. It is subject to the license terms in
the LICENSE file found in the top-level directory of this distribution and at
https://www.apache.org/licenses/LICENSE-2.0. No part of ODK Central,
including this file, may be copied, modified, propagated, or distributed
except according to the terms contained in the LICENSE file.
-->
<template>
  <div id="submission-list">
    <loading :state="fields.initiallyLoading"/>
    <div v-show="selectedFields != null">
      <div id="submission-list-actions" class="table-actions-bar">
        <template v-if="draft">
          <button id="submission-list-test-on-device" type="button"
            class="btn btn-outlined" @click="$emit('toggle-qr', $event.target)">
            <span class="icon-qrcode"></span>{{ $t('action.testOnDevice') }}
          </button>
          <enketo-fill v-if="formVersion.dataExists"
            id="submission-list-test-in-browser" :form-version="formVersion">
            <span class="icon-desktop"></span>{{ $t('action.testInBrowser') }}
          </enketo-fill>
        </template>
        <form v-if="!draft" class="form-inline" @submit.prevent>
          <submission-filters v-model:submitterId="submitterIds"
            v-model:submissionDate="submissionDateRange"
            v-model:reviewState="reviewStates"
            :disabled="deleted" :disabled-message="deleted ? $t('filterDisabledMessage') : null"/>
        </form>
        <!-- TODO: merge these two forms -->
        <form v-if="!draft" class="form-inline field-dropdown-form" @submit.prevent>
          <submission-field-dropdown
            v-if="selectedFields != null && fields.selectable.length > 11"
            v-model="selectedFields"/>
        </form>
        <button id="submission-list-refresh-button" type="button"
          class="btn btn-outlined" :aria-disabled="refreshing"
          @click="refresh">
          <span class="icon-refresh"></span>{{ $t('action.refresh') }}
          <spinner :state="refreshing"/>
        </button>
        <radio-field v-if="!draft && fields.dataExists && fields.hasMappable"
          v-model="dataView" :options="viewOptions" :disabled="encrypted"
          :disabled-message="$t('noMapEncryption')"/>
        <teleport-if-exists v-if="formVersion.dataExists && odata.dataExists"
          :to="'.form-submissions-heading-row'">
          <submission-download-button :form-version="formVersion"
            :aria-disabled="deleted"
            :filtered="odataFilter != null && !deleted"
            v-tooltip.aria-describedby="deleted ? $t('downloadDisabled') : null"
            @download="showDownloadModal"
            @download-filtered="showDownloadModal(true)"/>
        </teleport-if-exists>
      </div>

      <submission-table-view v-if="dataView === 'table'" ref="view"
        :project-id="projectId" :xml-form-id="xmlFormId" :draft="draft" :deleted="deleted"
        :filter="odataFilter" :fields="selectedFields"
        :refreshing="refreshing" :total-count="formVersion.submissions"
        :awaiting-responses="awaitingResponses"
        @review="reviewModal.show({ submission: $event })"
        @delete="showDelete"
        @restore="showRestore"/>
      <submission-map-view v-else ref="view"
        :project-id="projectId" :xml-form-id="xmlFormId" :deleted="deleted"
        :filter="geojsonFilter" :refreshing="refreshing"/>
      <p v-show="emptyTableMessage" class="empty-table-message">
        {{ emptyTableMessage }}
      </p>
    </div>

    <submission-download v-bind="downloadModal" :form-version="formVersion"
      @hide="downloadModal.hide(false)"/>
    <submission-update-review-state v-bind="reviewModal" :project-id="projectId"
      :xml-form-id="xmlFormId" @hide="reviewModal.hide()"
      @success="afterReview"/>
    <submission-delete v-bind="deleteModal" checkbox
      :awaiting-response="deleteModal.state && awaitingResponses.has(deleteModal.submission.__id)"
      @hide="deleteModal.hide()" @delete="requestDelete"/>
    <submission-restore v-bind="restoreModal" checkbox
      :awaiting-response="restoreModal.state && awaitingResponses.has(restoreModal.submission.__id)"
      @hide="restoreModal.hide()" @restore="requestRestore"/>
  </div>
</template>

<script>
import { shallowRef, watch } from 'vue';

import EnketoFill from '../enketo/fill.vue';
import Loading from '../loading.vue';
import Spinner from '../spinner.vue';
import RadioField from '../radio-field.vue';
import SubmissionDelete from './delete.vue';
import SubmissionDownload from './download.vue';
import SubmissionDownloadButton from './download-button.vue';
import SubmissionFieldDropdown from './field-dropdown.vue';
import SubmissionFilters from './filters.vue';
import SubmissionMapView from './map-view.vue';
import SubmissionRestore from './restore.vue';
import SubmissionTableView from './table-view.vue';
import SubmissionUpdateReviewState from './update-review-state.vue';
import TeleportIfExists from '../teleport-if-exists.vue';

import useFields from '../../request-data/fields';
import useQueryRef from '../../composables/query-ref';
import useDateRangeQueryRef from '../../composables/date-range-query-ref';
import useReviewState from '../../composables/review-state';
import useRequest from '../../composables/request';
import { apiPaths } from '../../util/request';
import { arrayQuery } from '../../util/router';
import { modalData } from '../../util/reactivity';
import { noop } from '../../util/util';
import { odataLiteral } from '../../util/odata';
import { useRequestData } from '../../request-data';

export default {
  name: 'SubmissionList',
  components: {
    EnketoFill,
    Loading,
    RadioField,
    Spinner,
    SubmissionDelete,
    SubmissionDownload,
    SubmissionDownloadButton,
    SubmissionFieldDropdown,
    SubmissionFilters,
    SubmissionMapView,
    SubmissionRestore,
    SubmissionTableView,
    SubmissionUpdateReviewState,
    TeleportIfExists
  },
  inject: ['alert'],
  props: {
    projectId: {
      type: String,
      required: true
    },
    xmlFormId: {
      type: String,
      required: true
    },
    draft: Boolean,
    deleted: Boolean,
    encrypted: Boolean
  },
  emits: ['fetch-keys', 'fetch-deleted-count', 'toggle-qr'],
  setup(props) {
    const { form, keys, resourceView, odata, submitters, deletedSubmissionCount } = useRequestData();
    const formVersion = props.draft
      ? resourceView('formDraft', (data) => data.get())
      : form;
    const fields = useFields();

    // Filter query parameters
    const submitterIds = useQueryRef({
      fromQuery: (query) => {
        const stringIds = arrayQuery(query.submitterId, {
          validator: (value) => /^[1-9]\d*$/.test(value)
        });
        return stringIds.length !== 0
          ? stringIds.map(id => Number.parseInt(id, 10))
          : (submitters.dataExists ? [...submitters.ids] : []);
      },
      toQuery: (value) => ({
        submitterId: value.length === submitters.length
          ? []
          : value.map(id => id.toString())
      })
    });
    watch(() => submitters.dataExists, () => {
      if (submitterIds.value.length === 0 && submitters.length !== 0)
        submitterIds.value = [...submitters.ids];
    });
    const submissionDateRange = useDateRangeQueryRef();
    const { reviewStates: allReviewStates } = useReviewState();
    const reviewStates = useQueryRef({
      fromQuery: (query) => arrayQuery(query.reviewState, {
        validator: (value) => allReviewStates.some(reviewState =>
          value === odataLiteral(reviewState)),
        default: () => allReviewStates.map(odataLiteral)
      }),
      toQuery: (value) => ({
        reviewState: value.length === allReviewStates.length ? [] : value
      })
    });

    const dataView = useQueryRef({
      fromQuery: (query) => (query.map === 'true' ? 'map' : 'table'),
      toQuery: (value) => ({ map: value === 'map' ? 'true' : null })
    });

    const { request } = useRequest();

    return {
      form, keys, fields, formVersion, odata, submitters, deletedSubmissionCount,
      submitterIds, submissionDateRange, reviewStates, allReviewStates, dataView,
      request
    };
  },
  data() {
    return {
      // selectedFields will be an array of fields. It needs to be shallow so
      // that the elements of the array are not reactive proxies. That's
      // important for SubmissionFieldDropdown, which will do exact equality
      // checks. (The selected fields that it passes to the Multiselect must be
      // among the options.)
      selectedFields: shallowRef(null),
      refreshing: false,
      // Modals
      downloadModal: modalData(),
      reviewModal: modalData(),
      deleteModal: modalData(),
      restoreModal: modalData(),

      // state that indicates whether we need to show delete confirmation dialog
      confirmDelete: true,
      // state that indicates whether we need to show restore confirmation dialog
      confirmRestore: true,

      awaitingResponses: new Set()
    };
  },
  computed: {
    viewOptions() {
      return [
        { value: 'table', text: this.$t('common.table') },
        { value: 'map', text: this.$t('common.map') }
      ];
    },
    filtersOnSubmitterId() {
      if (this.submitterIds.length === 0) return false;
      const selectedAll = this.submitters.dataExists &&
        this.submitterIds.length === this.submitters.length &&
        this.submitterIds.every(id => this.submitters.ids.has(id));
      return !selectedAll;
    },
    odataFilter() {
      if (this.draft) return null;

      const conditions = [];
      if (this.filtersOnSubmitterId) {
        const condition = this.submitterIds
          .map(id => `__system/submitterId eq ${id}`)
          .join(' or ');
        conditions.push(`(${condition})`);
      }
      if (this.submissionDateRange.length !== 0) {
        const start = this.submissionDateRange[0].toISO();
        const end = this.submissionDateRange[1].endOf('day').toISO();
        conditions.push(`__system/submissionDate ge ${start}`);
        conditions.push(`__system/submissionDate le ${end}`);
      }
      if (this.reviewStates.length !== this.allReviewStates.length) {
        const condition = this.reviewStates
          .map(reviewState => `__system/reviewState eq ${reviewState}`)
          .join(' or ');
        conditions.push(`(${condition})`);
      }
      return conditions.length !== 0 ? conditions.join(' and ') : null;
    },
    geojsonFilter() {
      if (this.draft) return null;
      const query = {};
      if (this.filtersOnSubmitterId) query.submitterId = this.submitterIds;
      if (this.submissionDateRange.length !== 0) {
        query.start__gte = this.submissionDateRange[0].toISO();
        query.end__lte = this.submissionDateRange[1].endOf('day').toISO();
      }
      if (this.reviewStates.length !== this.allReviewStates.length) {
        query.reviewState = this.reviewStates.map(reviewState =>
          // Undo odataLiteral(): remove quotes.
          (reviewState === 'null' ? reviewState : reviewState.slice(1, -1)));
      }
      return Object.keys(query).length !== 0 ? query : null;
    },
    emptyTableMessage() {
      if (!this.odata.dataExists) return '';
      if (this.odata.value.length > 0) return '';

      if (this.odata.removedSubmissions.size === this.odata.count && this.odata.count > 0) {
        return this.deleted ? this.$t('deletedSubmission.allRestored') : this.$t('allDeleted');
      }
      if (this.odata.removedSubmissions.size > 0 && this.odata.value.length === 0) {
        return this.deleted ? this.$t('deletedSubmission.allRestoredOnPage') : this.$t('allDeletedOnPage');
      }
      return this.deleted ? this.$t('deletedSubmission.emptyTable')
        : (this.odataFilter ? this.$t('noMatching') : this.$t('submission.emptyTable'));
    }
  },
  watch: {
    dataView() {
      /* Both view components set this.odata, but they don't reset this.odata
      when they're unmounted. It's important for this.odata to be reset,
      especially when toggling from table view to map view. Map view doesn't
      modify this.odata at all until after the GeoJSON response is received.
      That means that if this.odata isn't reset, the stale data from the table
      view could persist for a bit, affecting things like
      this.emptyTableMessage. */
      this.odata.reset();
    },
    'odata.count': {
      handler() {
        // Update this.formVersion.submissions to match this.odata.count.
        // this.odata.count is more likely to be up-to-date, since it's
        // refreshed more frequently. We don't update this.formVersion if
        // this.odata is a subset of submissions. That includes when the map
        // view sets this.odata, as some submissions might not have geo data and
        // won't appear on the map.
        if (this.formVersion.dataExists && this.odata.dataExists &&
          this.dataView === 'table' && !this.odataFilter)
          this.formVersion.submissions = this.odata.count;
      }
    },
    'odata.removedSubmissions.size': {
      handler(size) {
        if (this.formVersion.dataExists && this.odata.dataExists) {
          this.formVersion.submissions += this.deleted ? size : -size;
        }
      }
    }
  },
  created() {
    this.fetchData();
  },
  methods: {
    fetchData() {
      this.fields.request({
        url: apiPaths.fields(this.projectId, this.xmlFormId, this.draft, {
          odata: true
        })
      })
        .then(() => {
          // We also use 11 in the SubmissionFieldDropdown v-if.
          this.selectedFields = this.fields.selectable.length <= 11
            ? this.fields.selectable
            : this.fields.selectable.slice(0, 10);
        })
        .catch(noop);
      if (!this.draft) {
        this.submitters.request({
          url: apiPaths.submitters(this.projectId, this.xmlFormId, this.draft)
        }).catch(noop);
      }
    },
    refresh() {
      this.refreshing = true;
      this.$refs.view.refresh()
        .then(() => { this.refreshing = false; });

      // emit event to parent component to re-fetch deleted Submissions count
      if (!this.deleted && !this.draft) this.$emit('fetch-deleted-count');

      // emit event to parent component to re-fetch keys if needed
      if (this.formVersion.keyId != null && this.keys.length === 0)
        this.$emit('fetch-keys');
    },
    // This method accounts for the unlikely case that the user clicked the
    // refresh button before reviewing the submission. In that case, the
    // submission may have been edited or may no longer be shown.
    afterReview(originalSubmission, reviewState) {
      this.reviewModal.hide();
      this.alert.success(this.$t('alert.updateReviewState'));
      const index = this.odata.value.findIndex(submission =>
        submission.__id === originalSubmission.__id);
      if (index !== -1) {
        this.odata.value[index].__system.reviewState = reviewState;
        this.$refs.view.afterReview(index);
      }
    },
    showDelete(submission) {
      if (this.confirmDelete) {
        this.deleteModal.show({ submission });
      } else {
        this.requestDelete([submission, this.confirmDelete]);
      }
    },
    showRestore(submission) {
      if (this.confirmRestore) {
        this.restoreModal.show({ submission });
      } else {
        this.requestRestore([submission, this.confirmRestore]);
      }
    },
    requestDelete(event) {
      const [{ __id: instanceId }, confirm] = event;

      this.awaitingResponses.add(instanceId);

      this.request({
        method: 'DELETE',
        url: apiPaths.submission(this.projectId, this.xmlFormId, instanceId)
      })
        .then(() => {
          this.deleteModal.hide();
          if (this.deletedSubmissionCount.dataExists) this.deletedSubmissionCount.value += 1;

          this.alert.success(this.$t('alert.submissionDeleted'));
          if (confirm != null) this.confirmDelete = confirm;

          this.odata.removedSubmissions.add(instanceId);
          /* Before doing a couple more things, we first determine whether
          this.odata.value still includes the Submission and if so, what the
          current index of the Submission is. If a request to refresh
          this.odata (or the GeoJSON) was sent while the deletion request was in
          progress, then there could be a race condition such that data doesn't
          exist for this.odata, or this.odata.value no longer
          includes the Submission. Another possible result of the race condition is
          that this.odata.value still includes the Submission, but the
          Submission's index has changed. */
          const index = this.odata.dataExists
            ? this.odata.value.findIndex(submission => submission.__id === instanceId)
            : -1;
          if (index !== -1) {
            this.$refs.view.afterDelete(index);
            this.odata.value.splice(index, 1);
          }
        })
        .catch(noop)
        .finally(() => {
          this.awaitingResponses.delete(instanceId);
        });
    },
    requestRestore(event) {
      const [{ __id: instanceId }, confirm] = event;

      this.awaitingResponses.add(instanceId);

      this.request({
        method: 'POST',
        url: apiPaths.restoreSubmission(this.projectId, this.xmlFormId, instanceId)
      })
        .then(() => {
          this.restoreModal.hide();
          if (this.deletedSubmissionCount.dataExists && this.deletedSubmissionCount.value > 0) {
            this.deletedSubmissionCount.value -= 1;
          }

          this.alert.success(this.$t('alert.submissionRestored'));
          if (confirm != null) this.confirmRestore = confirm;

          this.odata.removedSubmissions.add(instanceId);

          // See the comments in requestDelete().
          const index = this.odata.dataExists
            ? this.odata.value.findIndex(submission => submission.__id === instanceId)
            : -1;
          if (index !== -1) {
            this.$refs.view.afterDelete(index);
            this.odata.value.splice(index, 1);
          }
        })
        .catch(noop)
        .finally(() => {
          this.awaitingResponses.delete(instanceId);
        });
    },
    showDownloadModal(filtered = false) {
      this.downloadModal.odataFilter = filtered ? this.odataFilter : null;
      this.downloadModal.show();
    }
  }
};
</script>

<style lang="scss">
@import '../../assets/scss/variables';

#submission-list {
  // Make sure that there is enough space for the DateRangePicker when it is
  // open.
  &:has(.date-range-picker) { min-height: 375px; }
}

#submission-list-actions {
  align-items: center;
  display: flex;
  flex-wrap: wrap-reverse;
  // This results in 10px of space between elements on the row, as well as 10px
  // between rows if elements start wrapping. The main example of that is that
  // the download button can wrap above the other actions if the viewport is not
  // wide enough.
  gap: 10px;
}

// Adjust the spacing between actions on the draft testing page.
#submission-list-test-in-browser {
  ~ .form-inline {
    // It is possible for .form-inline to be :empty, but we still render it so
    // that the buttons that follow it are shown on the righthand side of the
    // page.
    margin-left: auto;

    #submission-field-dropdown {
      // There are no filters, so no need for margin-left.
      margin-left: 0;
      // Further increase the space between the dropdown and the refresh button.
      margin-right: 10px;
    }
  }

  ~ #submission-download-button { margin-left: 0; }
}

#submission-list .radio-field { margin-left: auto; }

#submission-table:has(tbody tr) + .empty-table-message {
  display: none;
}
</style>

<i18n lang="json5">
{
  "en": {
    "action": {
      "testOnDevice": "Test on device",
      "testInBrowser": "Test in browser"
    },
    "noMatching": "There are no matching Submissions.",
    "allDeleted": "All Submissions are deleted.",
    "allDeletedOnPage": "All Submissions on the page have been deleted.",
    "downloadDisabled": "Download is unavailable for deleted Submissions",
    "filterDisabledMessage": "Filtering is unavailable for deleted Submissions",
    "noMapEncryption": "Map is unavailable due to Form encryption",
    "deletedSubmission": {
      "emptyTable": "There are no deleted Submissions.",
      "allRestored": "All deleted Submissions are restored.",
      "allRestoredOnPage": "All Submissions on the page have been restored."
    }
  }
}
</i18n>

<!-- Autogenerated by destructure.js -->
<i18n>
{
  "cs": {
    "noMatching": "Neexistují žádné odpovídající příspěvky."
  },
  "de": {
    "action": {
      "testOnDevice": "Test am Gerät",
      "testInBrowser": "Test im Browser"
    },
    "noMatching": "Es gibt keine passenden Übermittlungen.",
    "allDeleted": "Alle Übermittlungen werden gelöscht.",
    "allDeletedOnPage": "Alle Übermittlungen auf dieser Seite wurden gelöscht.",
    "downloadDisabled": "Der Download ist für gelöschte Übermittlungen nicht verfügbar",
    "filterDisabledMessage": "Filterung ist für gelöschte Übermittlungen nicht verfügbar",
    "deletedSubmission": {
      "emptyTable": "Es gibt keine gelöschten Übermittlungen.",
      "allRestored": "Alle gelöschten Übermittlungen werden wiederhergestellt.",
      "allRestoredOnPage": "Alle Übermittlungen auf dieser Seite wurden wiederhergestellt."
    }
  },
  "es": {
    "action": {
      "testOnDevice": "Prueba en el dispositivo",
      "testInBrowser": "Prueba en el navegador"
    },
    "noMatching": "No hay envíos coincidentes.",
    "allDeleted": "Todos los envíos se han eliminado.",
    "allDeletedOnPage": "Se han eliminado todos los envíos de la página.",
    "downloadDisabled": "La descarga no está disponible para los envíos eliminados",
    "filterDisabledMessage": "El Filtro no está disponible para los Envíos eliminados",
    "deletedSubmission": {
      "emptyTable": "No hay envíos eliminados.",
      "allRestored": "Se restablecen todos los envíos eliminados.",
      "allRestoredOnPage": "Se han restablecido todas las Envíos de la página."
    }
  },
  "fr": {
    "action": {
      "testOnDevice": "Tester sur un appareil",
      "testInBrowser": "Tester dans le naviguateur"
    },
    "noMatching": "Il n'y a pas de soumission correspondante.",
    "allDeleted": "Toutes les soumissions sont supprimées.",
    "allDeletedOnPage": "Toutes les soumissions de la page ont été supprimées.",
    "downloadDisabled": "Le téléchargement n'est pas possible pour les Soumissions supprimées.",
    "filterDisabledMessage": "Le filtrage n'est pas possible pour les Soumissions supprimées.",
    "deletedSubmission": {
      "emptyTable": "Il n'y a pas de Soumissions supprimées",
      "allRestored": "Toutes les Soumissions supprimées ont été restaurées.",
      "allRestoredOnPage": "Toutes les Soumissions de la page ont été restaurées."
    }
  },
  "id": {
    "noMatching": "Tidak ada Pengiriman yang cocok."
  },
  "it": {
    "action": {
      "testOnDevice": "Testa sul dispositivo",
      "testInBrowser": "Testa nel browser"
    },
    "noMatching": "Non sono presenti invii corrispondenti.",
    "allDeleted": "Tutti gli invii vengono cancellati.",
    "allDeletedOnPage": "Tutti gli invii presenti nella pagina sono stati cancellati.",
    "downloadDisabled": "Il download non è disponibile per gli invii cancellati",
    "filterDisabledMessage": "Il filtro non è disponibile per gli invii cancellati.",
    "deletedSubmission": {
      "emptyTable": "Non ci sono invii cancellati.",
      "allRestored": "Tutti gli invii cancellati vengono ripristinati.",
      "allRestoredOnPage": "Tutti i contributi presenti nella pagina sono stati ripristinati."
    }
  },
  "ja": {
    "noMatching": "照合できる提出済フォームはありません。"
  },
  "pt": {
    "action": {
      "testOnDevice": "Testar no dispositivo'",
      "testInBrowser": "Testar no navegador"
    },
    "noMatching": "Não foram encontradas respostas com esses parâmetros.",
    "allDeleted": "Todas as Respostas foram excluídas.",
    "allDeletedOnPage": "Todas as Respostas nesta página foram excluídas.",
    "downloadDisabled": "O download está indisponível para Respostas excluídas",
    "filterDisabledMessage": "A filtragem está indisponível para Respostas excluídas",
    "deletedSubmission": {
      "emptyTable": "Não há Respostas excluídas"
    }
  },
  "sw": {
    "noMatching": "Hakuna Mawasilisho yanayolingana."
  },
  "zh-Hant": {
    "action": {
      "testOnDevice": "在設備上測試",
      "testInBrowser": "在瀏覽器中測試"
    },
    "noMatching": "沒有符合的提交內容。",
    "allDeleted": "所有提交內容都會被刪除。",
    "allDeletedOnPage": "頁面上的所有提交內容都已刪除。",
    "downloadDisabled": "已刪除的提交內容無法下載",
    "filterDisabledMessage": "無法對已刪除的提交內容進行過濾",
    "deletedSubmission": {
      "emptyTable": "沒有已刪除的提交內容。",
      "allRestored": "所有已刪除的提交內容都會還原。",
      "allRestoredOnPage": "頁面上的所有提交內容都已還原。"
    }
  }
}
</i18n>
